import AnchorSystem from '../../../../components/images/AnchorSystem'
import AnchorSystemOverview from './../../../../components/images/anchor_system_docs_light.png'
import AnchorRelayerSystem from '../../../../components/images/AnchorRelayerSystem'
import Image from 'next/image'


# The Anchor System of Webb Protocol

## Introduction


<img src="/Users/thomivy/webb-docs/components/images/anchor_system_docs_light.png" alt="Overview of the Anchor system"/>


This technical documentation is designed to provide a comprehensive understanding of the Anchor System, a cutting-edge blockchain bridging infrastructure. The Anchor System is a complex network comprised of interlinked smart contract protocols or pallet protocols, orchestrated to synchronize and validate data across different blockchains. 
The Anchor System can be described as a bridged network system that interfaces a set of identical smart contract protocols. At its core, it leverages merkle trees across different blockchains to foster a graph-like network where anchors maintain the updated state of their neighboring anchors. This comprehensive state data is then utilized to verify the existence of data in any anchor from any other anchor. The primary objective of the Anchor System revolves around two fundamental properties:

- **Liveness:** It ensures all anchors can continue to be updated in a partially-synchronous environment.
- **Safety:** It guarantees all anchor updates to be valid, safeguarding the integrity of the network.
- **Privacy:** It guarentees that user data is kept private.


## Anchor System Architecture

The Anchor System is comprises Anchor Contracts, which are composed of an EdgeList and Merkle Trees, and operated by Users, Oracles, and Relayers. 

### Anchor Contracts
Anchor Contracts act as the cornerstone of the Anchor System. They carry a vital role in defining the rules, maintaining data, and managing state in the network. Each anchor contract maintains an on-chain merkle tree and an edge list. The edge list is updated via the external governance system. This allows anchors to stay in sync across chains.

<AnchorSystem />


**Elements**
The elements stored in anchors are 32-byte hashes representing applications. The hashes enable privacy, while zero knowledge proofs verify preimage knowledge.

**EdgeMetadata**
Each anchor maintains an edge list containing `EdgeMetadata` objects, an `EdgeList`, a history of the merkle root updates up to some bounded limit.

Here is an example of an `EdgeMetadata` data structure that represents an edge in the system:

```rust
// An edge for a specific chain
pub struct EdgeMetadata<ChainID, Element, LastLeafIndex> {
	/// chain id of the connected merkle tree
	pub src_chain_id: ChainID,
	/// root of source chain anchor's native merkle tree
	pub root: Element,
	/// height of source chain anchor's native merkle tree
	pub latest_leaf_index: LastLeafIndex,
	/// target system of the anchor (contract address or tree id)
	pub target: Element,
}
```

**EdgeList**
The primary purpose of the `EdgeList` is to keep track of the connections between anchors. This includes keeping track of the latest state of each anchor and the historical changes in state. Each EdgeList is a data structure that contains a set of EdgeMetadata objects, which represent the edges (direct connections) between anchors. The structure of the EdgeList is implemented as a hash map in which the key is a ChainID and the value is an EdgeMetadata object. The EdgeList is used to track the state of neighboring anchors, including their latest updates. It also serves as a historical record of merkle root updates.

 An `EdgeList` data structure might look like:

```rust
/// An example of an edge list data structure
struct EdgeList<ChainID, Element, LastLeafIndex> {
	/// Map of edges 
	pub edges: HashMap<ChainID, EdgeMetadata<ChainID, Element, LastLeafIndex>>,
	/// Map of historical roots (chain -> index -> merkle root)
	pub history: HashMap<ChainId, HashMap<u8, Element>>
}
```

## Merkle Trees
Merkle Trees are data structures that enable secure and efficient storage, verification, and querying of data across the network. They're primarily used to verify whether specific data points exist within a data set.

A Merkle Tree is a binary tree where each non-leaf node is the hash of its child nodes. The leaf nodes, in turn, are hashes of the input data or elements. The elements represent the application underlying a connected anchor bridge.

The principal application of Merkle Trees within the Anchor System involves generating proofs of membership. These proofs verify an element's existence within a tree and comprise a path from the root to the leaf node containing only the nodes necessary for validation.


### Data and Message Flow
The interaction between the participants in the Anchor System involves a continuous flow of data and messages:

**Insertions:** Users can insert elements (32-byte hashes of arbitrary data) into the anchors' Merkle trees. The insertion process involves creating a new leaf node in the Merkle tree, then updating the parent nodes up to the root of the tree.

**Observation and Relay:** Oracles monitor these insertions, generate the relevant EdgeMetadata, and relay this data to the governing system. Following approval from the governing system, the Oracles relay this outcome back to the respective anchors, keeping the system's state current.

**Relaying and Privacy Preservation:** Relayers listen for user requests to submit zero-knowledge proofs of membership. They then relay these proofs to the appropriate destinations in the network, preserving user privacy throughout the process.

**Proving Membership:** Users can independently or via relayers generate zero-knowledge proofs of membership. These proofs attest to the existence of an element in an anchor's Merkle tree without exposing more data than necessary.



## Privacy
A major goal of the Anchor System is to enable privacy-preserving transactions and data transfer between different blockchains. The system accomplishes this through the use of zero-knowledge proofs of membership in anchors' merkle trees.

Specifically, the Anchor System allows users to generate proofs that demonstrate membership of data in one of many merkle trees across different anchors, without revealing which specific tree contains that data.

For example, consider a system with 5 anchors `(A1, A2, A3, A4, A5)` on different blockchains. Each anchor maintains its own merkle tree of data. A user wants to generate a proof that some data X exists in the trees without revealing which tree exactly.

The user can generate a zero-knowledge proof that shows X is a member of the set of trees `{A1, A2, A3, A4, A5}` without specifying which one. Verifiers can validate that X indeed exists in one of the trees, but have no way of knowing precisely which tree it is in.

This privacy mechanism arises because the anchors share their tree roots with each other, allowing membership to be proven in any tree. But the trees themselves remain private.

As more anchors are added to the system, the anonymity set for users grows. With 5 anchors, the proof could be for any one of 5 trees. With 10 anchors, the proof shows membership in 1 of 10 trees - increasing privacy.

Overall, the collaborative privacy model enabled by anchors' merkle trees is crucial for building scalable, decentralized systems that require transactions and data sharing across chains to be private. The zero-knowledge proofs allow verifying correctness without leaking unnecessary metadata.

### Zero-knowledge Membership
The main utility of the Anchor System is the ability to prove membership of elements in any anchor on a bridge in zero-knowledge. These proofs of membership disclose no more data than is necessary to prove that there exists an element with some defined preimage structure in one-of-many of the anchors.

The primary sketch for a zero-knowledge membership program and proof in the Anchor System is:

- A proof of knowledge of preimage of an element in the anchor.
- A proof of knowledge of membership of an element in a merkle tree.
-A proof of knowledge of membership of a merkle root in a set of merkle roots.

The membership proof here is unique for a given element but need not be in practice. That is, we could envision an Anchor System where multiple element types are supported and multiple zero-knowledge programs are provided for verification of membership proofs. For example, we may consider an Anchor System over a UTXO a decentralized identity ([DID](https://www.w3.org/TR/did-core/)) elements together.


## Validation
The Validation Protocol in the Anchor System ensures that updates to anchors are authorized and secure. For an Anchor System integrated with the Tangle Network, validation can be performed using the Tangle consensus mechanism.

In the Anchor System, the Validation Protocol can leverage the Tangle Network to validate anchor updates as follows:
## The Anchor Update Process on the Tangle Network:

1. **Initiation**: 
   - An anchor update begins with the creation of a special "anchor update" transaction on the Tangle. This transaction carries details about the proposed change.
  
2. **Transaction Reference**: 
   - To issue this anchor update transaction, the issuer references and approves two prior transactions on the Tangle.

3. **Validation by Nodes**: 
   - The nodes on the Tangle then scrutinize this anchor update transaction. They ensure it adheres to Tangle's rules and doesn't clash with the existing ledger state.

4. **Consensus & Confirmation**: 
   - After gathering adequate approvals via the Tangle's consensus mechanism, the transaction is deemed confirmed.

5. **State Update**: 
   - Anchor contracts recognize these confirmed Tangle transactions as valid updates to the state. The anchor then executes the update request on-chain. If the Tangle transaction meets the approval criteria set for "anchoring", the anchor's state is updated accordingly.

6. **Benefits**: 
   - This procedure leverages the decentralized nature and robust security of the Tangle Network for validating updates. Additionally, participants of the Tangle play a crucial role in authenticating anchor modifications.


## Roles

#### Oracles and the Oracle Network
Oracles are pivotal in the functioning of the Anchor System. They are tasked with observing, validating, and communicating changes across all anchors.

Specifically, the key functions of oracles are:

- Listening for new insertions into anchors’ merkle trees.
- Composing the `EdgeMetadata` objects from these observations.
- Relaying these `EdgeMetadata` objects to the governing system of the Anchor System instance.
- Relaying the output of the governing system back to the respective anchors.

They actively monitor network alterations, which are assessed based on the rules outlined by the anchor contracts. The oracles take on the responsibility of transmitting these validated modifications to the external governance system.

<AnchorRelayerSystem />

In practice, the oracle and relayers roles are synergistic and often taken out by the same participant in the protocol. While we remark about these roles separately, we often consider them as being undertaken by the same party. We use the terms interchangeably to represent the network that provides both relaying and oracle services in the Anchor System.

#### Relayers and the Relayer Network
Relayers are essential actors within the Anchor System, serving to maintain the privacy of users as they engage with the anchor instances. They facilitate the transfer of zero-knowledge proof data to the target system on behalf of users, thus enabling them to interact with the system without sacrificing their privacy.

In any blockchain context, users are required to possess funds in order to interact and transact with smart contracts. Therefore, if a privacy-interested user intends to prove membership of some element’s preimage in one of the anchors’ merkle trees, they must be able to do so without compromising their privacy by requiring them to submit these proofs themselves. They must be able to delegate the submission of their proof through some overlay network.

The relayer network provides this delegation service. Anyone can run a relayer and provide this service. We consider an agent a relayer if they expose an API that enables the submission of zero-knowledge proofs of membership for specific anchor instances and if this agent submits the relevant transaction on-chain on behalf of the user delegating their proof through this API.

Relayer incentives are key component of ensuring privacy for end users utilizing the applications built over the Anchor System instance. Incentives are highly coupled to the applications implemented. For example, for a private bridge application, users can pay a fee to relayers by committing to a specified fee at proof generation which is extracted and transferred out of the users transfer to the relayer’s account.

Relayers are compensated for their services through fees collected during the proof generation stage by the users. These fees are then moved to the relayer's account as a form of recompense.

In practice, the oracle and relayers roles are synergistic and often taken out by the same participant in the protocol. While we remark about these roles separately, we often consider them as being undertaken by the same party. We use the terms interchangeably to represent the network that provides both relaying and oracle services in the Anchor System.

#### Users
Users are the individuals or entities who interact with the system by inserting data into an Anchor's Merkle tree and generating proofs of membership of their data in a Merkle tree. They may also use the system to validate the existence of specific data across the network.





## External Governance System

The Anchor System requires governance mechanisms to validate proposed changes to anchor state, such as updates to an anchor's edge list. The system supports various governance regimes:

### Proof-based 

Proof-based governance allows state changes that are accompanied by valid cryptographic proofs. Examples include:

- Zero-knowledge proofs
- Fraud proofs 
- Light client proofs

Proofs demonstrate the validity of state changes in a trustless and decentralized way.

### Signature-based 

Signature-based governance approves changes through signatures from approved accounts. This includes:

- ECDSA signatures from individual accounts
- Threshold signatures from multiple accounts

Valid signatures from authorized signers allow state changes. The set of signers is agreed upon external to the system.

### Token-weighted 

In token-weighted governance, state changes are approved based on token votes from stakeholders. Tokens can be weighted by different factors to provide fine-grained control over governance influence.

For example, tokens may be weighted by time locked, by amount staked, or by designation as a governance-only token. Heavier weighted votes from token holders approve changes.

The Anchor System governance model allows flexibility to match the needs of different applications. Proof and signature based models promote decentralization, while token-weighted models allow for tuned governance incentives.