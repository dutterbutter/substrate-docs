---
title: Overview
slug: /v1/relayer/overview
version: '1.0'
section: docs
category: relayer
keywords: []
---

Bridges are networked applications that span multiple blockchains and must be aware of events and/or state occurring
across this network. The endponts of these bridges (e.g. the smart contracts / core protocol logic) are denoted
`Anchors` in the Webb Protocol. These Anchors are required by definition to know about various parts of the state of other
anchors, particularly the ones they're connected to across a particular bridge. The backbone of any bridge is made
up of the relayers -- otherwise denoted validators, relayers, authorities, nodes, etc. -- that maintain the
liveliness of the bridge protocol.

A blockchain oracle is a system that listens to an external data source and posts this data back on-chain to
arbitrarily many blockchains. Examples of data sources include, but not limited to:

- Price feeds of USD/ETH pair (Chainlink)
- Weather feeds in Europe
- Merkle tree roots on different anchors (Webb)

In the Webb Protocol, relayers fulfill the role of an oracle where the external data sources that they listen to
are the state of the anchors for a bridge. Relayers, as their name entails, relay information for a connected set
of Anchors on a bridge. This information is then used to update the state of each Anchor and allow applications
to reference, both privately and potentially not, properties of data stored across the other connected Anchors.

The responsibility for a relayer to the Anchor protocol is the following:

1. Listen to all the anchors of a bridge.
2. When a new deposit or insertion occurs in one of the merkle trees, say `A`, the relayer will construct:

   ```rust
   edge = EdgeMetadata {
   		src_chain_id: A,
   		root: merkle_root_after_latest_insertion,
   		latest_leaf_index: index_of_the_latest_leaf_inserted
   }
   ```

3. After constructing the edge metadata, the relayer relays this edge to all neighbouring anchors.

   ```rust
   edges(A) = all the neighboring anchors to A
   // all the chain ids of anchors connected to anchor A
   anchor_chain_ids(A) = edges(A).map(edge => edge.src_chain_id)
   // send an update to each connected anchor
   for anchor_chain_id in anchor_chain_ids(A) {
   		propose update(anchor_chain_id, edge)
   }
   ```

The above

## Relayer and DKG Interaction

The relayers act as proposers of proposals intended to be signed by the distributed key generation protocol (DKG).

1. The relayers are listening to and proposing updates.
2. The DKG is signing these updates using a [threshold-signature scheme](https://en.wikipedia.org/wiki/Threshold_cryptosystem).
   1. We say its a threshold signature because it requires a threshold of participants _t-out-of-n_ to generate a full signature.

We require a threshold of relayers (_really proposers_) to agree on the update in order to move the update into a queue for the DKG to sign from.

## Relayer Roadmap

We aim to build a relayer infrastructure that gradually improves in its performance, efficiency, and overall security. We do this in stages by first building the necessary infrastructure to listen to events across a connected set of Anchors and react properly across a Bridge to preserve the liveness of the protocol.

### **Version 1 - Multi-sig governance functionality**

The first iteration of the bridge relayer is responsible for event listening and transaction execution.

- Event listening across a set of connected anchors to learn of new deposits on a Bridge.
- Proposal creation and vote submission over the Bridge's governance process.
- Data replication and an API for inspecting Anchor state off-chain.

### **Version 2 - Multi-party Threshold governance functionality**

We then plan to integrate a DKG into a Substrate node for future governance purposes.

- Direct integration into a (currently) Substrate chain or potentially other blockchain node (Cosmos-SDK)
  - Bootstraps off existing validator set and participates in consensus.
- Execution of a distributed key generation protocol to generate a threshold key.

### **Version 3 - Auxiliary staking and punishment functionality**

We will integrate the DKG directly into the Bridge governance system, allowing the bridge to be governed by a threshold key (or many).

- Integrate staking mechanism over finality authorities for registering local key matter.
- Integrate punishment mechanism over improper behavior in the DKG.
- Develop an on-chain pallet to govern the threshold and generate threshold signatures of `Bridge.sol` governance transactions.
