---
title: Overview
slug: /v1/dkg/overview
version: '1.0'
section: docs
category: dkg
keywords: []
---

This page will provide an overview of the Distributed Key Generation (DKG) protocol, what it is,
its intended use, and how it interacts with the wider system.

The primary purpose of the DKG protocol is to govern the Anchor protocol. More precisely, the DKG
act as a security instrument to the Anchor protocol, that is, we say that the bridge updates are
valid if they are signed by the DKG. The security of the system then rests on the DKG signing the
actual data that it is meant to sign.

## What is a DKG

A [DKG](https://en.wikipedia.org/wiki/Distributed_key_generation) is a cryptographic process in which
mupliple participants contribute to the calculation of a shared public and private key set in a trustless
manner. In the Webb network, the DKG is comprised of two protocols:

1. Threshold-key-generation
2. Threshold-signature-scheme

The (1) distributed key generation protocol takes a secret parameter as input, and outputs the private signing key (sk) and public key (pk). The returned private signing key (sk) is only a share of the private key, where the values of all returned private signing key shares constitute a (t,n) threshold secret sharing of the private signing key.

![dkg-keygen.png](../../../../src/images/docs/dkg/dkg-keygen.png)

The (2) distributed signing protocol takes the private signing key (sk) of each network participant, and the message to be signed (m) as inputs. The output is a valid signature. The public input message are updates (proposals) that are being signed using a threshold-signature-scheme.

![dkg-signing](../../../../src/images/docs/dkg/dkg-signing.png)

The DKG makes use of these distributed key generation and signing protocols to govern distributed applications. Specifically, having arbitrary messages or proposals that represent requested changes to a system to be voted on, and if a simple majority is achieved, to be signed by a threshold of network participants. A valid signature on a proposal would then signal those requested changes to be true.

## How proposals are signed

The below sequence diagram illustrates the steps required to successfully submit an **Anchor Update Proposal**
for signature.

1. Proposers propose an anchor update
2. Proposers vote to either reject or acknowledge the proposal
3. If the majority vote to reject, the execution is canceled and the proposal rejection event is emitted
4. If the majority vote in favour of the proposal, the execution to have that proposal signed begins
5. The proposal is inserted into an Unsigned Proposal Queue
6. The DKG-gadget an offchain service worker, fetches the unsigned proposal from the queue
7. The DKG-gadget sends messages to all connected peers to be signed in the given or next round
8. Upon the completion of the round, the now signed proposals are processed and stored in offchain storage
9. The Proposal-Handlers offchain worker then fetches signed proposals
10. The proposals signatures are validated and inserted into pallet storage
11. A ProposalSigned event is emitted indicating a successfully submitted proposal

![Simplified DKG proposal signing sequence](../../../../src/images/docs/dkg/proposal-signing.png)

The current DKG implementation manages the following proposals, each specify a unique change to the system that must be signed in order for any of these requested updates to be considered valid.

| Proposals                  | Description                          |
| -------------------------- | ------------------------------------ |
| Refresh                    | Request to refresh shared public key |
| AnchorCreate               |                                      |
| AnchorUpdate               | Request to update merkle roots       |
| SetVerifierProposal        |                                      |
| TokenAdd                   | Request to add token                 |
| TokenRemove                | Request to remove token              |
| WrappingFeeUpdate          | Request to update fee                |
| RescueToken                | Request to move tokens into Treasury |
| MaxDepositLimitUpdate      |                                      |
| MinWithdrawalLimitUpdate   |                                      |
| FeeRecipientUpdateProposal |                                      |
| SetTreasuryHandlerProposal |                                      |
| MaxExtLimitUpdate          |                                      |
| MaxFeeLimitUpdate          |                                      |
| ResourceIdUpdate           | Request to update resource id        |
| ProposalSetUpdate          |                                      |

## Key rotation

On a new session, the new authorities (from validators or collators) are selected and the next authorities
are selected.

1. These next authorities run **_keygen_** protocol and output a new group keypair on-chain, denoted
   `next_dkg_public_key`.
2. The current authorities (having already run this process in the step before) see this event and if
   it is time to refresh, they begin to sign the `next_dkg_public_key` with their key, the `dkg_public_key`.
3. The signature from the active keypair of the next keypair is posted on-chain.
4. Once this signature is posted, anyone can propagate it.
   - Any relayer.
   - Any user who wants to update the governor of their contract.

## Pallets

The DKG runtime is uses the following pallets which are central to how the protocol functions.

### pallet-dkg-metadata

This pallet essentially tracks the information about the current and next authority sets, including the set Ids.
It does this by implementing the `OneSessionHandler` trait which allows it to receieve both new and queued authority sets when the session changes.

- [Docs]()
- [Source]()

### pallet-parachain-staking

This is a custom staking pallet that handles collator selection, This pallet helps the protocol select new collators based on amount staked.
It also allows for nominators, who back collators by staking their assets, both collators and nominators are rewarded after every session comes to an end.
Reward for collators and their nominators is dependent on how many points accrued by the collator during the session,
these points are gained by successfully authoring blocks.

This pallet implements the `SessionManager` trait and that way is able to provide the the selected collators as validators to the session pallet.

- [Docs]()
- [Source]()

### pallet-dkg-proposals

This pallet handles maintaining valid proposers and also voting on proposals.
The valid set of proposers is equivalent to the current DKG authorities. This pallet gains access to the current DKG authorities by
implementing the `OnAuthoritySetChangedHandler` trait, that way it is able to receive the updated DKG authorities from `pallet-dkg-metadata`.

This pallet maintains a queue for pending proposals which the DKG authorities vote on and if the vote threshold is met, the proposal is passed on to be handled
by a type that implements the `ProposalHandlerTrait`.

In this current iteration the proposals are Ethereum transactions.

- [Docs]()
- [Source]()

### pallet-dkg-proposal-handler

This pallet implements the `ProposalHandlerTrait` accepts proposals and signs them using the DKG authority keys.

- [Docs]()
- [Source]()

### pallet-dkg-mmr

This pallet serves as a leaf provider for the `pallet-mmr`, generating leaf data that contains a merke root hash for a particular authority set.

It also provides a type that has an implementation for converting `ECDSA` keys to ethereum compatible keys.

- [Docs]()
- [Source]()

### dkg-gadget

The DKG gadget is an offchain service that executes the DKG protocol and stores data in offchain storage for the on-chain system to fetch and update with. It also listens to changes in the proposal handler and metadata pallets in order to properly:

- Rotate keys
- Sign unsigned proposals
- Set and clear offchain storage
- Report slashing

We are always executing a DKG protocol for the current authority set **and the next authority set**.

- [Docs]()
- [Source]()

### Note on Offchain workers

The DKG makes use of offchain workers to submit some extrinsics back on chain and the runtime validates that the origin of such extrinsics is part of the active or queued authoritiy set, if running a development node or a local test net, the sr25519 account keys
for the predefined validators Alice, Bob, etc, have been added to the keystore for convenience.

If running a live chain as a validator or collator, please add your sr25519 account keys to the node's local keystore either by using the `author_insertKey` RPC or using the `key` subcommand (`dkg-standalone-node key insert --key-type acco --scheme sr25519 --suri <path-secret-phrase>`) of the node cli

> Key Type is acco
> Scheme is sr25519

**Note**
For the standalone node the account being added to the keystore should be the Stash account used in staking not the Controller account
