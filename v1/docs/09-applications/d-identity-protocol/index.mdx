---
title: Overview
slug: /v1/applications/identity-protocol
version: '1.0'
section: docs
category: ispp
keywords: []
---

import ProtocolImages from './protocol.js'

The asset protocol we describe here is inspired and based off of Semaphore Protocol, an identity protocol that allows for private arbitrary signaling (voting for example) on the blockchain while proving that the user is part of a group in the semaphore set.

In our version of the asset protocol we will leverage Webbâ€™s technology to design an interoperable identity protocol that allows both for signaling on the same chain as the group was initially created or on one of the other connected chains

### Identities

The Semaphore protocol allows us to create arbitrary merkle-trees. Each leaf has a 32-bytes value and a user can prove membership by proving that he knows the secret to the leaf and the merkle-path to it.

Currently, each identity is just a pair (`identityNullifier`, `identityTrapdoor`), but we can use different nullifier schemes to create each leaf. For example the VUF Nullifier scheme as described in [https://eprint.iacr.org/2022/1255]

### Preventing double signaling

Double signaling is only bad depending on the application. If we're deploying a forum, for example, a user posting twice is expected behaviour.

Because of this, the double signalling prevention is dependent on the application. E.g. For the voting system, the ballotID is the nullifier.

In the base contract (`Semaphore.sol`) and interface (`Semaphore.ts`), the nullifier being used for verification can be any uint256, so there's no attempt to prevent any kind of double signaling since the user can send the same signal multiple times by just generating another random nullifier each time.

On the extensions, there's an already implemented logic for preventing double signaling. On the `SemaphoreVoting.sol` example, the pollID is the same as the nullifierHash, so each user can only vote one time per poll.

```
identityCommitment = Poseidon(identityNullifier, identityTrapdoor)
```

## Developer Usage

% TODO

## Circuit

The zero-knowledge circuit encodes a variety of constraints to ensure that the identity system works properly. This includes, among other things, the constraints necessary to prove that a user is part of a valid merkle-tree.

The constraints required are:

- To verify the correctness of `identity nullifiers`
- To verify the uniqueness of `external nullifier`
- To verify the existence of input `identityCommitments`
- To verify correctness of merkle-path and merkle-root

### Formal description

<ProtocolImages />

## References

- [https://semaphore.appliedzkp.org/](https://semaphore.appliedzkp.org/)
