---
title: Overview
slug: /v1/applications/identity-protocol
version: '1.0'
section: docs
category: ispp
keywords: []
---

import IdentityImages from './identity.js'

The asset protocol we describe here is inspired and based off of Semaphore Protocol, an identity protocol that allows for private arbitrary signaling (voting for example) on the blockchain while proving that the user is part of a group in the semaphore set.

In our version of the asset protocol we will leverage Webbâ€™s technology to design an interoperable identity protocol that allows both for signaling on the same chain as the group was initially created or on one of the other connected chains

### Identities

The Semaphore protocol allows us to create arbitrary merkle-trees. Each leaf has a 32-bytes value and a user can prove membership by proving that he knows the secret to the leaf and the merkle-path to it.

Currently, each identity is just a pair (`identityNullifier`, `identityTrapdoor`), but we can use different nullifier schemes to create each leaf. For example the VUF Nullifier scheme as described in [https://eprint.iacr.org/2022/1255]

### Preventing double signaling

Double signaling is only bad depending on the application. If we're deploying a forum, for example, a user posting twice is expected behaviour.

Because of this, the double signalling prevention is dependent on the application. E.g. For the voting system, the ballotID is the nullifier.

In the base contract (`Semaphore.sol`) and interface (`Semaphore.ts`), the nullifier being used for verification can be any uint256, so there's no attempt to prevent any kind of double signaling since the user can send the same signal multiple times by just generating another random nullifier each time.

On the extensions, there's an already implemented logic for preventing double signaling. On the `SemaphoreVoting.sol` example, the pollID is the same as the nullifierHash, so each user can only vote one time per poll.

```
identityCommitment = Poseidon(identityNullifier, identityTrapdoor)
```

## Circuit

The zero-knowledge circuit encodes a variety of constraints to ensure that the identity system works properly. This includes, among other things, the constraints necessary to prove that a user is part of a valid merkle-tree.

The constraints required are:

- To verify the correctness of `identity nullifiers`
- To verify the uniqueness of `external nullifier`
- To verify the existence of input `identityCommitments`
- To verify correctness of merkle-path and merkle-root

## Developer Usage

One interesting possibility on how to use Semaphore is to use its contract just to manage groups, while managing circuit and double spending prevention logic on another repo. Example: `https://github.com/webb-tools/protocol-solidity/pull/182`

We have a Semaphore contract deployed at the following addresses.
```
Ethereum testnet: TBD
Arbitrum testnet: TBD
...

```

Integration should proceed as follows

1. Add the Semaphore contract interface to your contracts.
2. Point the interface to the corresponding address to the chain you're deploying on.
3. Add a groupId parameter to your smart-contract. You may consider making it immutable.
4. Define your group on the Semaphore contract using the Semaphore interface by pointing to the contract address as follows:
```
import { Semaphore } from '@webb-tools/semaphore';

const wasmPath = path.resolve(
  __dirname,
  <relative_path_to_wasm_file>
);
const witnessCalcPath = path.resolve(
  __dirname,
  <relative_path_to_witness_calc_file>
);
const zkeyPath = path.resolve(
  __dirname,
  <relative_path_to_zkey_file>
);
zkComponents2_2 = await fetchComponentsFromFilePaths(
  wasmPath,
  witnessCalcPath,
  zkeyPath
);
// zkComponents2_2 is duplicated. This is not a good interface for a one (fixed-size) or more than two possible validator sets.
const semaphore = Semaphore.connect("<contract_address>", zkComponents2_2, zkComponents2_2, signer);

const levels = 30 // between 1 and 32
const groupId = <random_value> // just need to make sure it isn't taken
const maxEdges = <number_of_chains_connected_to_this_one> // Currently supported (1, 7)

await semaphore.createGroup(groupId, levels,  signer.address, maxEdges);

let members: List<BigNumber> = ... // Create members using same logic as in the circuit being used.
await semaphore.addMembers(groupId, members);
```

Your group is ready on the semaphore contract. Now you should just point its interface to the correct address and group ID.


### Formal description

<IdentityImages />

## References

- [https://semaphore.appliedzkp.org/](https://semaphore.appliedzkp.org/)
